sentiment
}
getSentiment <- function(df) {
# Convert Tweet texts to corpus datatype
corpus = SimpleCorpus(VectorSource(df$Text))
# Continue to clean corpus
corpus = tm_map(corpus, stripWhitespace)
corpus = tm_map(corpus, content_transformer(tolower))
corpus = tm_map(corpus, removeNumbers)
corpus = tm_map(corpus, removePunctuation)
corpus = tm_map(corpus, removeWords, stopwords("english"))
# Stemming
corpus = tm_map(corpus, stemDocument)
# Document-Term Matrix
dtm = DocumentTermMatrix(corpus)
sentiment = analyzeSentiment(dtm, language = "english")
sentiment
}
for (i in 1:5) {
split.dfs[[i]]$Partial = i
if (i == 1) {
tmp <- getSentiment(split.dfs[[i]])
} else {
tmp <- rbind(tmp, getSentiment(split.dfs[[i]]))
}
}
warnings()
partial.4 <- tweets[75001:10000,]
partial.4 <- tweets[75001:100000,]
partial.5 <- tweets[100001:n,]
split.dfs <- list(partial.1, partial.2, partial.3, partial.4, partial.5)
rm(tmp)
for (i in 1:5) {
split.dfs[[i]]$Partial = i
if (i == 1) {
tmp <- getSentiment(split.dfs[[i]])
} else {
tmp <- rbind(tmp, getSentiment(split.dfs[[i]]))
}
}
View(tmp)
View(partial.1)
a <- cbind(tweets, tmp)
View(a)
names(tmp)
qdap <- subset(tmp, select=c(SentimentQDAP, NegativityQDAP, PositivityQDAP))
tweets <- stream_in(file("tweets.json"), pagesize = 10000)
tweets$Text <- tolower(tweets$Text)
tweets$DisneyPlus = ifelse(grepl("#disneyplus", tweets$Text), 1, 0)
tweets$DisneyPlusFail = ifelse(grepl("#disneyplusfail", tweets$Text), 1, 0)
a <- cbind(tweets, qdap)
View(a)
ggplot(a, aes(x=Created_at, y=SentimentQDAP)) +
geom_point()
ggplot(a, aes(x=Created_at, y=SentimentQDAP, color=DisneyPlusFail)) +
geom_point()
ggplot(a, aes(x=Created_at, y=SentimentQDAP, fill=DisneyPlusFail)) +
geom_jitter()
fail <- subset(a, DisneyPlusFail == 1)
ggplot(fail, aes(x=Created_at, y=SentimentQDAP)) +
geom_jitter()
ggplot(fail, aes(x=Created_at, y=SentimentQDAP)) +
geom_boxplot()
View(fail)
plus <- subset(a, DisneyPlus == 1)
ggplot(plus, aes(x=Created_at, y=SentimentQDAP)) +
geom_boxplot()
ggplot(fail, aes(y=SentimentQDAP)) +
geom_boxplot()
ggplot(plus, aes(y=SentimentQDAP)) +
geom_boxplot()
ggplot(fail, aes(SentimentQDAP)) +
geom_density()
ggplot(plus, aes(y=SentimentQDAP)) +
geom_density()
ggplot(plus, aes(SentimentQDAP)) +
geom_density()
fail <- subset(a, DisneyPlusFail == 1 & DisneyPlus == 0)
fail <- subset(a, (DisneyPlusFail == 1 & DisneyPlus == 0)))
fail <- subset(a, (DisneyPlusFail == 1 & DisneyPlus == 0))
fail <- subset(a, (DisneyPlusFail == 1 & Both == 0))
fail <- subset(a, (DisneyPlusFail == 1 & DisneyPlu == 0))
fail <- subset(a, (DisneyPlusFail == 1 & DisneyPlus == 0))
tweets$DisneyPlus = ifelse(grepl("#disneyplus(?!f)", tweets$Text, perl=TRUE), 1, 0)
tweets$DisneyPlusFail = ifelse(grepl("#disneyplusfail", tweets$Text), 1, 0)
fail <- subset(a, (DisneyPlusFail == 1 & DisneyPlus == 0))
a <- cbind(tweets, qdap)
fail <- subset(a, (DisneyPlusFail == 1 & DisneyPlus == 0))
plus <- subset(a, (DisneyPlus == 1 & DisneyPlusFail == 0)
)
ggplot(fail, aes(SentimentQDAP)) +
geom_density()
ggplot(fail, aes(SentimentQDAP)) +
geom_boxplot()
ggplot(fail, aes(y=SentimentQDAP)) +
geom_boxplot()
ggplot(plus, aes(y=SentimentQDAP)) +
geom_boxplot()
a$Descriptor <- ifelse((DisneyPlus == 1 & DisneyPlusFail == 0), "#DisneyPlus",
ifelse((DisneyPlus == 0 & DisneyPlusFail == 1), "#DisneyPlusFail",
"Both"))
a$Descriptor <- ifelse((a$DisneyPlus == 1 & a$DisneyPlusFail == 0), "#DisneyPlus",
ifelse((a$DisneyPlus == 0 & a$DisneyPlusFail == 1), "#DisneyPlusFail",
"Both"))
View(a)
ggplot(a, aes(x=Descriptor, y=SentimentQDAP)) +
geom_boxplot()
ggplot(a, aes(SentimentQDAP, fill=Descriptor)) +
geom_density()
ggplot(a, aes(x=Date, y=SentimentQDAP)) +
geom_boxplot()
ggplot(a, aes(x=Created_at, y=SentimentQDAP)) +
geom_boxplot()
ggplot(a, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot()
ggplot(a, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor, fill=Descriptor)) +
geom_boxplot()
ggplot(a, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot()
rm(list=ls())
# Read the json file using a stream,
# since it is too big to read all at once
tweets <- stream_in(file("tweets.json"), pagesize = 10000, verbose = FALSE)
# Convert Tweet text to lower case, for standardization
tweets$Text <- tolower(tweets$Text)
# Remove duplicates (Tweets that we received from both API calls)
# This does not remove Retweets
tweets <- unique(tweets)
# Identify Tweets using the different hashtags
tweets$DisneyPlus = ifelse(grepl("#disneyplus(?!f)", tweets$Text, perl=TRUE), 1, 0)
tweets$DisneyPlusFail = ifelse(grepl("#disneyplusfail", tweets$Text), 1, 0)
tweets$Both = ifelse(tweets$DisneyPlus == 0, 0, ifelse(tweets$DisneyPlusFail == 1, 1, 0))
# Count the number of Tweets per hashtag on different days
compressed <- tweets %>%
group_by(Created_at) %>%
summarise(DisneyPlus = sum(DisneyPlus),
DisneyPlusFail = sum(DisneyPlusFail),
Both = sum(Both))
compressed$Day <- c("Tuesday - Release Day", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
# Display results
compressed
View(tweets)
View(compressed)
View(tweets)
View(tweets)
# Calculate sentiment of each Tweet using the SentimentAnalysis package
getSentiment <- function(df) {
# Convert Tweet texts to corpus datatype
corpus = SimpleCorpus(VectorSource(df$Text))
# Continue to clean corpus
corpus = tm_map(corpus, stripWhitespace)
corpus = tm_map(corpus, removeNumbers)
corpus = tm_map(corpus, removePunctuation)
corpus = tm_map(corpus, removeWords, stopwords("english"))
# Stemming - Convert words to their stems, for standardization
corpus = tm_map(corpus, stemDocument)
# Generate Document-Term Matrix from matrix
dtm = DocumentTermMatrix(corpus)
sentiment = analyzeSentiment(dtm, language = "english")
sentiment
}
# Split our tweets up for analysis,
# due to memory restraints
n <- length(rownames(tweets))
partial.1 <- tweets[1:25000,]
partial.2 <- tweets[25001:50000,]
partial.3 <- tweets[50001:75000,]
partial.4 <- tweets[75001:100000,]
partial.5 <- tweets[100001:n,]
split.dfs <- list(partial.1, partial.2, partial.3, partial.4, partial.5)
# Call the getSentiment() function on each of our smaller datasets
# and bind the results into a single file for all of the Tweets
for (i in 1:5) {
if (i == 1) {
partial.sentiment <- getSentiment(split.dfs[[i]])
} else {
partial.sentiment <- rbind(tmp, getSentiment(split.dfs[[i]]))
}
}
# Calculate sentiment of each Tweet using the SentimentAnalysis package
getSentiment <- function(df) {
# Convert Tweet texts to corpus datatype
corpus = SimpleCorpus(VectorSource(df$Text))
# Continue to clean corpus
corpus = tm_map(corpus, stripWhitespace)
corpus = tm_map(corpus, removeNumbers)
corpus = tm_map(corpus, removePunctuation)
corpus = tm_map(corpus, removeWords, stopwords("english"))
# Stemming - Convert words to their stems, for standardization
corpus = tm_map(corpus, stemDocument)
# Generate Document-Term Matrix from matrix
dtm = DocumentTermMatrix(corpus)
sentiment = analyzeSentiment(dtm, language = "english")
sentiment
}
# Split our tweets up for analysis,
# due to memory restraints
n <- length(rownames(tweets))
partial.1 <- tweets[1:25000,]
partial.2 <- tweets[25001:50000,]
partial.3 <- tweets[50001:75000,]
partial.4 <- tweets[75001:100000,]
partial.5 <- tweets[100001:n,]
split.dfs <- list(partial.1, partial.2, partial.3, partial.4, partial.5)
# Call the getSentiment() function on each of our smaller datasets
# and bind the results into a single file for all of the Tweets
for (i in 1:5) {
if (i == 1) {
partial.sentiment <- getSentiment(split.dfs[[i]])
} else {
partial.sentiment <- rbind(partial.sentiment, getSentiment(split.dfs[[i]]))
}
}
# SentimentAnalysis uses multiple dictionaries for sentiment analysis,
# but let's just focus on their QDAP dictionary
qdap <- subset(tmp, select=c(SentimentQDAP, NegativityQDAP, PositivityQDAP))
# SentimentAnalysis uses multiple dictionaries for sentiment analysis,
# but let's just focus on their QDAP dictionary
qdap <- subset(partial.sentiment, select=c(SentimentQDAP, NegativityQDAP, PositivityQDAP))
# Combine the sentiment data back with the Tweet data from the API
tweets <- cbind(tweets, qdap)
# Categorize Tweets as either having "#DisneyPlus#, "#DisneyPlusFail", or both of them
tweets$Descriptor <- ifelse((tweets$DisneyPlus == 1 & tweets$DisneyPlusFail == 0), "#DisneyPlus",
ifelse((tweets$DisneyPlus == 0 & tweets$DisneyPlusFail == 1), "#DisneyPlusFail",
"Both"))
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot()
View(partial.sentiment)
original <- subset(tweets, tweets$Retweet != "Retweet")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(original, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot()
View(original)
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot()
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal()
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none") +
annotate("text", x=3.5, y = 1, label="More Positive")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none") +
annotate("text", x=3.5, y = 1, label="More Positive")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
annotate("text", x=3.5, y = 1, label="More Positive") +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.5, y = 1, label="More Positive") +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.5, y = 0.5, label="More Positive", color="Green") +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.5, y = 0.5, label="More Positive", color="darkgreen") +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.5, y = 0.5, label="More Positive", color="darkgreen", angle=90) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.5, y=0.5, label="More Positive", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.5, y=0.5, label="More Negative", color="darkred", angle=90) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.5, y=0.5, label="More Positive", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.5, y=-0.5, label="More Negative", color="darkred", angle=90) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.2, y=0.5, label="More Positive", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.2, y=-0.5, label="More Negative", color="darkred", angle=90) +
geom_segment(aes(x=3.7, y = 0.2, xend = 3.7, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.2, y=0.5, label="More Positive", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.2, y=-0.5, label="More Negative", color="darkred", angle=90) +
geom_segment(aes(x=3.4, y = 0.2, xend = 3.7, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.3, y=0.5, label="More Positive", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.3, y=-0.5, label="More Negative", color="darkred", angle=90) +
geom_segment(aes(x=3.4, y = 0.2, xend = 3.4, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
geom_segment(aes(x=3.4, y = -0.2, xend = -3.4, yend = 0.8),
color='darkred', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.3, y=0.5, label="More Positive/Happy", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.3, y=-0.5, label="More Negative/Upset", color="darkred", angle=90) +
geom_segment(aes(x=3.4, y = 0.2, xend = 3.4, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
geom_segment(aes(x=3.4, y = -0.2, xend = 3.4, yend = -0.8),
color='darkred', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.3, y=0.5, label="More Positive / Happy", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.3, y=-0.5, label="More Negative / Upset", color="darkred", angle=90) +
geom_segment(aes(x=3.4, y = 0.2, xend = 3.4, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
geom_segment(aes(x=3.4, y = -0.2, xend = 3.4, yend = -0.8),
color='darkred', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
geom_jitter() +
theme_minimal() +
ggplot2::annotate("text", x=3.3, y=0.5, label="More Positive / Happy", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.3, y=-0.5, label="More Negative / Upset", color="darkred", angle=90) +
geom_segment(aes(x=3.4, y = 0.2, xend = 3.4, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
geom_segment(aes(x=3.4, y = -0.2, xend = 3.4, yend = -0.8),
color='darkred', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_violin() +
geom_jitter(alpha=0.05) +
theme_minimal() +
ggplot2::annotate("text", x=3.3, y=0.5, label="More Positive / Happy", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.3, y=-0.5, label="More Negative / Upset", color="darkred", angle=90) +
geom_segment(aes(x=3.4, y = 0.2, xend = 3.4, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
geom_segment(aes(x=3.4, y = -0.2, xend = 3.4, yend = -0.8),
color='darkred', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_violin() +
theme_minimal() +
ggplot2::annotate("text", x=3.3, y=0.5, label="More Positive / Happy", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.3, y=-0.5, label="More Negative / Upset", color="darkred", angle=90) +
geom_segment(aes(x=3.4, y = 0.2, xend = 3.4, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
geom_segment(aes(x=3.4, y = -0.2, xend = 3.4, yend = -0.8),
color='darkred', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_violin() +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.3, y=0.5, label="More Positive / Happy", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.3, y=-0.5, label="More Negative / Upset", color="darkred", angle=90) +
geom_segment(aes(x=3.4, y = 0.2, xend = 3.4, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
geom_segment(aes(x=3.4, y = -0.2, xend = 3.4, yend = -0.8),
color='darkred', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
geom_violin() +
theme_minimal() +
ggplot2::annotate("text", x=3.3, y=0.5, label="More Positive / Happy", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.3, y=-0.5, label="More Negative / Upset", color="darkred", angle=90) +
geom_segment(aes(x=3.4, y = 0.2, xend = 3.4, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
geom_segment(aes(x=3.4, y = -0.2, xend = 3.4, yend = -0.8),
color='darkred', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.3, y=0.5, label="More Positive / Happy", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.3, y=-0.5, label="More Negative / Upset", color="darkred", angle=90) +
geom_segment(aes(x=3.4, y = 0.2, xend = 3.4, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
geom_segment(aes(x=3.4, y = -0.2, xend = 3.4, yend = -0.8),
color='darkred', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
# Combine the sentiment data back with the Tweet data from the API
tweets <- cbind(tweets, partial.sentiment)
# Categorize Tweets as either having "#DisneyPlus#, "#DisneyPlusFail", or both of them
tweets$Descriptor <- ifelse((tweets$DisneyPlus == 1 & tweets$DisneyPlusFail == 0), "#DisneyPlus",
ifelse((tweets$DisneyPlus == 0 & tweets$DisneyPlusFail == 1), "#DisneyPlusFail",
"Both"))
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.3, y=0.5, label="More Positive / Happy", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.3, y=-0.5, label="More Negative / Upset", color="darkred", angle=90) +
geom_segment(aes(x=3.4, y = 0.2, xend = 3.4, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
geom_segment(aes(x=3.4, y = -0.2, xend = 3.4, yend = -0.8),
color='darkred', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
tweets <- stream_in(file("tweets.json"), pagesize = 10000, verbose = FALSE)
# Convert Tweet text to lower case, for standardization
tweets$Text <- tolower(tweets$Text)
# Remove duplicates (Tweets that we received from both API calls)
# This does not remove Retweets
tweets <- unique(tweets)
# Identify Tweets using the different hashtags
tweets$DisneyPlus = ifelse(grepl("#disneyplus(?!f)", tweets$Text, perl=TRUE), 1, 0)
tweets$DisneyPlusFail = ifelse(grepl("#disneyplusfail", tweets$Text), 1, 0)
tweets$Both = ifelse(tweets$DisneyPlus == 0, 0, ifelse(tweets$DisneyPlusFail == 1, 1, 0))
# Combine the sentiment data back with the Tweet data from the API
tweets <- cbind(tweets, partial.sentiment)
# Categorize Tweets as either having "#DisneyPlus#, "#DisneyPlusFail", or both of them
tweets$Descriptor <- ifelse((tweets$DisneyPlus == 1 & tweets$DisneyPlusFail == 0), "#DisneyPlus",
ifelse((tweets$DisneyPlus == 0 & tweets$DisneyPlusFail == 1), "#DisneyPlusFail",
"Both"))
# Create boxplots for our 3 categories of Tweets, and their respective sentiments
ggplot(tweets, aes(x=Descriptor, y=SentimentQDAP, color=Descriptor)) +
geom_boxplot() +
theme_minimal() +
ggplot2::annotate("text", x=3.3, y=0.5, label="More Positive / Happy", color="darkgreen", angle=90) +
ggplot2::annotate("text", x=3.3, y=-0.5, label="More Negative / Upset", color="darkred", angle=90) +
geom_segment(aes(x=3.4, y = 0.2, xend = 3.4, yend = 0.8),
color='darkgreen', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
geom_segment(aes(x=3.4, y = -0.2, xend = 3.4, yend = -0.8),
color='darkred', size=0.5, arrow = arrow(length = unit(0.5, "cm"))) +
labs(x="Hashtag used", y="Sentiment Score") +
theme(legend.position="none")
saveRDS(file="tweets_with_sentiment.rds", tweets)
# Read the json file using a stream,
# since it is too big to read all at once
tweets <- stream_in(file("tweets.json"), pagesize = 10000, verbose = FALSE)
# Convert Tweet text to lower case, for standardization
tweets$Text <- tolower(tweets$Text)
# Remove duplicates (Tweets that we received from both API calls)
# This does not remove Retweets
tweets <- unique(tweets)
# Identify Tweets using the different hashtags
tweets$DisneyPlus = ifelse(grepl("#disneyplus(?!f)", tweets$Text, perl=TRUE), 1, 0)
tweets$DisneyPlusFail = ifelse(grepl("#disneyplusfail", tweets$Text), 1, 0)
tweets$Both = ifelse(tweets$DisneyPlus == 0, 0, ifelse(tweets$DisneyPlusFail == 1, 1, 0))
# Count the number of Tweets per hashtag on different days
compressed <- tweets %>%
group_by(Created_at) %>%
summarise(DisneyPlus = sum(DisneyPlus),
DisneyPlusFail = sum(DisneyPlusFail),
Both = sum(Both))
compressed$Day <- c("Tuesday - Release Day", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
# Display results
compressed
